using System;
using System.CodeDom.Compiler;
using MtconnectTranspiler.Sinks.CSharp.Contracts.Interfaces;
using Package = Mtconnect.Fundamentals;

namespace Mtconnect
{
	/// <summary>
	/// The MTConnect Standard defines the normative information model and protocol for retrieving information from manufacturing equipment. This document specifies the <i>agent</i> behavior and protocol.  ## Agent  The MTConnect Standard specifies the minimum functionality of the <i>agent</i>. The functionality is as follows:  * Provides store and forward messaging middleware service. * Provides key-value information storage and asset retrieval service. * Implements the REST API for the MTConnect Standard (See <see cref="REST Protocol">REST Protocol</see>).   * <i>Device</i> metadata.   * <i>observation</i>s collected by the agent.   * <i>asset</i>s collected by the agent.  There are three types of information stored by an <i>agent</i> that <b>MAY</b> be published in a <i>response document</i>. These are as follows:  * <i>equipment metadata</i> specified in <see cref="Device Information Model">Device Information Model</see>. * <i>streaming data</i> provides the <i>observation</i>s specified in <see cref="Observation Information Model">Observation Information Model</see>. * <i>Asset</i>s specified in <see cref="Asset Information Model">Asset Information Model</see>.  ### Agent Instance ID  The <i>agent</i> <b>MUST</b> set the <c>instanceId</c> to a unique value whenever the <i>sequence number</i> in the agent is initialized to <c>1</c>.  (see <see cref="Sequence Numbers">Sequence Numbers</see> and <see cref="Persistence and Recovery">Persistence and Recovery</see> below).   ### Storage of Equipment Metadata  An <i>agent</i> <b>MUST</b> be capable of publishing <i>equipment metadata</i> for the <i>agent</i> as specified in <see cref="Device Information Model">Device Information Model</see>.  ### Storage of Streaming Data  The <i>agent</i> <b>MAY</b> implement a <i>buffer</i> with a fixed number of <i>observation</i>s. If the <c>bufferSize</c> is fixed, the <i>agent</i> <b>MUST</b> store <i>observation</i>s using a first-in-first-out pattern. The <i>agent</i> will remove the oldest <i>observation</i> when the <i>buffer</i> is full and a new <i>observation</i> arrives.  ![Data Storage in Buffer](figures/data-storage-in-buffer.png "data-storage-in-buffer"){: width="0.8"}  In {{figure(first-in-first-out-buffer-management)}}, the maximum number of <i>observation</i>s that can be stored in the <i>buffer</i> of the <i>agent</i> is 8. The <c>bufferSize</c> in the header reports the maximum number of <i>observation</i>s. This example illustrates that when the <i>buffer</i> fills up, the oldest piece of data falls out the other end.  ![First In First Out Buffer Management](figures/first-in-first-out-buffer-management.png "first-in-first-out-buffer-management"){: width="0.8"}  > Note: As an implementation suggestion, the <i>buffer</i> should be sized large enough to provide a continuous stream of <i>observation</i>s. The implementer should also consider the impact of a temporary loss of communications when determining the size for the <i>buffer</i>. A larger <i>buffer</i> will allow more time to reconnect to an <i>agent</i> without losing data.  #### Sequence Numbers  In an <i>agent</i>, each occurrence of an <i>observation</i> in the <i>buffer</i> will be assigned a monotonically increasing unsigned 64-bit integer (<i>sequence number</i>) when it arrives. The first <i>sequence number</i> <b>MUST</b> be <c>1</c>.  The <i>sequence number</i> for each <i>observation</i> <b>MUST</b> be unique for an instance of an <i>agent</i> identified by an <c>instanceId</c>.  {{table(instanceid-and-sequence)}} illustrates the changing of the <c>instanceId</c> when an <i>agent</i> resets the <i>sequence number</i> to <c>1</c>.  | <c>instanceId</c> | <c>sequence</c> |  |-------------:|-----------:| |{{rowspan(5)}} 234556|234| ||235| ||236| ||237| ||238| |{{span(2)}} Agent Stops and Restarts| |{{rowspan(5)}} 234557|1| ||2| ||3| ||4| ||5| {: caption="instanceId and sequence" label="instanceid-and-sequence" }  {{figure(identifying-the-range-of-data-with-firstsequence-and-lastsequence)}} shows two additional pieces of information defined for an <i>agent</i>:  * <c>firstSequence</c> -- the oldest <i>observation</i> in the <i>buffer</i>. The <i>agent</i> removes this <i>observation</i> when it receives the next <i>observation</i>  * <c>lastSequence</c> -- the newest <i>observation</i> in the <i>buffer</i>  <c>firstSequence</c> and <c>lastSequence</c> provide the range of values for the REST API requests.  ![Indentifying the range of data with firstSequence and lastSequence](figures/identifying-the-range-of-data-with-firstsequence-and-lastsequence.png "identifying-the-range-of-data-with-firstsequence-and-lastsequence"){: width="0.75"}  The <i>agent</i> <b>MUST</b> begin evaluating <i>observation</i>s with <i>sample request</i>'s <c>from</c> parameter. Also, the <i>agent</i>  <b>MUST</b> include a maximum number of <i>observation</i>s given by the <c>count</c> parameter in the <i>response document</i>.  In {{figure(identifying-the-range-of-data-with-from-and-count)}}, the request specifies the <i>observation</i>s start at <i>sequence number</i> <c>15</c> (<c>from</c>) and includes a total of three items (<c>count</c>).  ![Identifying the range of data with from and count](figures/identifying-the-range-of-data-with-from-and-count.png "identifying-the-range-of-data-with-from-and-count"){: width="0.75"}  <c>nextSequence</c> header property has the <i>sequence number</i> of the next <i>observation</i> in the <i>buffer</i> for subsequent <i>sample request</i>s providing a contiguous set of <i>observation</i>s. In the example in {{figure(identifying-the-range-of-data-with-from-and-count)}}, the next <i>sequence number</i> (<c>nextSequence</c>) will be 18.  As shown in {{figure(identifying-the-range-of-data-with-nextsequence-and-lastsequence)}}, the combination of <c>from</c> and <c>count</c> defined by the <i>request</i> indicates a <i>sequence number</i> for data that is beyond that which is currently in the <i>buffer</i>. In this case, <c>nextSequence</c> is set to a value of <i> lastSequence + 1 </i>s.  ![Indentifying the range of data with nextSequence and lastSequence](figures/identifying-the-range-of-data-with-nextsequence-and-lastsequence.png "identifying-the-range-of-data-with-nextsequence-and-lastsequence"){: width="0.75"}  #### Observation Buffer  An <i>observation</i> has four pieces of information as follows:  1. <i>sequence number</i> associated with each <i>observation</i> - <c>sequence</c>. 2. The <c>timestamp</c> the <i>observation</i> was made. . 3. A reference to the <c>dataitemid</c> from the <see cref="Device Information Model">Device Information Model</see>. 4. The value of the <i>observation</i>.  {{table(data-storage-concept)}} is an example demonstrating the concept of how data may be stored in an <i>agent</i>:  | <c>sequence</c> | <c>timestamp</c> | <c>dataItemId</c> | <c>result</c> | |-----------:|------------:|-------------:|---------:| |<c>101</c>|<c>2016-12-13T09:44:00.2221Z</c>|<c>AVAIL-28277</c>|<c>UNAVAILABLE</c>| |<c>102</c>|<c>2016-12-13T09:54:00.3839Z</c>|<c>AVAIL-28277</c>|<c>AVAILABLE</c>| |<c>103</c>|<c>2016-12-13T10:00:00.0594Z</c>|<c>POS-Y-28277</c>|<c>25.348</c>| |<c>104</c>|<c>2016-12-13T10:00:00.0594Z</c>|<c>POS-Z-28277</c>|<c>13.23</c>| |<c>105</c>|<c>2016-12-13T10:00:03.2839Z</c>|<c>SS-28277</c>|<c>0</c>| |<c>106</c>|<c>2016-12-13T10:00:03.2839Z</c>|<c>POS-X-28277</c>|<c>11.195</c>| |<c>107</c>|<c>2016-12-13T10:00:03.2839Z</c>|<c>POS-Y-28277</c>|<c>24.938</c>| |<c>108</c>|<c>2016-12-13T10:01:37.8594Z</c>|<c>POS-Z-28277</c>|<c>1.143</c>| |<c>109</c>|<c>2016-12-13T10:02:03.2617Z</c>|<c>SS-28277</c>|<c>1002</c>| {: caption="Data Storage Concept" label="data-storage-concept" }  #### Timestamp  <i>observation</i>s <b>MUST</b> have a <c>timestamp</c> giving the most accurate time that the <i>observation</i> occurred.  The timezone of the <c>timestamp</c> <b>MUST</b> be UTC (Coordinated Universal Time)  and represented using ISO 8601 format: e.g., "2010-04-01T21:22:43Z".  Applications <b>SHOULD</b> use the <i>observation</i>'s <c>timestamp</c> for ordering as opposed to <i>sequence number</i>.  All <i>observation</i>s occurring at the same time <b>MUST</b> have the same <c>timestamp</c>.   #### Recording Occurrences of Streaming Data  The <i>agent</i> <b>MUST</b> only place <i>observation</i>s in the <i>buffer</i> if the data has changed from the previous <i>observation</i> for the same <see cref="DataItem">DataItem</see>.   The <i>agent</i> <b>MUST</b> place every <i>observation</i> in the <i>buffer</i>, without checking for changes, in the following cases:  * The <see cref="DataItem::discrete" /> is <c>true</c>.  * The <see cref="DataItem::representation" /> is <c>DISCRETE</c>. * The <see cref="DataItem::representation" /> is <c>TIME_SERIES</c>.  #### Maintaining Last Value for Data Entities  An <i>agent</i> <b>MUST</b> retain the most recent <i>observation</i> associated with each <see cref="DataItem">DataItem</see>, even if the <i>observation</i> is no longer in the <i>buffer</i>. This function supports the <i>current request</i> functionality.  #### Unavailability of Data  An <i>observation</i> with the value of <c>UNAVAILABLE</c> indicates the value is indeterminate.  The <i>agent</i> <b>MUST</b> initialize every <see cref="DataItem">DataItem</see>, unless it has a constant value (see below), with an <i>observation</i> with the value of <c>UNAVAILABLE</c>. Aditionally, whenever the data source is unreachable, every <see cref="DataItem">DataItem</see> associated with the data source must have an <i>observation</i> with the value of <c>UNAVAILABLE</c> and <c>timestamp</c> when the connection was lost.   An <see cref="DataItem">DataItem</see> that is constrained to a constant value, as defined in <see cref="Device Information Model">Device Information Model</see>, <b>MUST</b> only have an <i>observation</i> with the constant value and <b>MUST NOT</b> be set to <c>UNAVAILABLE</c>.  #### Persistence and Recovery  The <i>agent</i> <b>MAY</b> have a fixed size <i>buffer</i> and the <i>buffer</i> <b>MAY</b> be ephemeral.  If the <i>buffer</i> is recoverable, the <i>agent</i> <b>MUST NOT</b> change the <c>instanceId</c> and <b>MUST NOT</b> set the <i>sequence number</i> to <c>1</c>. The <i>sequence number</i> <b>MUST</b> be one greater than the maximum value of the recovered <i>observation</i>s. <i> max(sequence) + 1 </i>s  ### Storage of MTConnect Assets  An <i>agent</i> <b>MAY</b> only retain a limited number of <see cref="Asset">Asset</see>s in the <i>asset buffer</i>. The <see cref="Asset">Asset</see>s are stored in first-in-first-out method where the oldest <see cref="Asset">Asset</see> is removed when the <i>asset buffer</i> is full and a new <see cref="Asset">Asset</see> arrives.  {{figure(first-in-first-out-asset-buffer-management)}} illustrates the oldest <see cref="Asset">Asset</see> being removed from the <i>asset buffer</i> when a new <see cref="Asset">Asset</see> is added and the <i>asset buffer</i> is full:  ![First In First Out Asset Buffer Management](figures/first-in-first-out-asset-buffer-management.png "first-in-first-out-asset-buffer-management"){: width="0.6"}  <see cref="Asset">Asset</see>s are indexed by <see cref="Asset::assetId" />. In the case of <see cref="Asset">Asset</see>s, {{figure(relationship-between-assetid-and-stored-asset-documents)}} demonstrates the relationship between the key (<see cref="Asset::assetId" />) and the stored <see cref="Asset">Asset</see>:  ![Relationship between assetId and stored Asset documents](figures/relationship-between-assetid-and-stored-asset-documents.png "relationship-between-assetid-and-stored-asset-documents"){: width="0.25"}  > Note: The key (<see cref="Asset::assetId" />) is independent of the order of the <see cref="Asset">Asset</see> stored in the <i>asset buffer</i>.  When the <i>agent</i> receives a new <see cref="Asset">Asset</see>, one of the following rules <b>MUST</b> apply:  * If the <see cref="Asset">Asset</see> is not in the <i>asset buffer</i>, the <i>agent</i> <b>MUST</b> add the new <see cref="Asset">Asset</see> to the front of the <i>asset buffer</i>. If the <i>asset buffer</i> is full, the oldest <see cref="Asset">Asset</see> will be removed from the <i>asset buffer</i>.  * If the <see cref="Asset">Asset</see> is already in the <i>asset buffer</i>, the <i>agent</i> <b>MUST</b> replace the existing <see cref="Asset">Asset</see> and move the <see cref="Asset">Asset</see> to the front of the <i>asset buffer</i>.   The number of <see cref="Asset">Asset</see> that may be stored in an <i>agent</i> is defined by the value for <see cref="Header::assetBufferSize" />. An <see cref="Header::assetBufferSize" /> of 4,294,967,296 or <i> 2^{32 } </i>s <b>MUST</b> indicate unlimited storage.  The <i>asset buffer</i> <b>MAY</b> be ephemeral and the <see cref="Asset">Asset</see> entities will be lost if the <i>agent</i> clears the <i>asset buffer</i>. They must be recovered from the data source.  <see cref="Asset Information Model">Asset Information Model</see> provides additional information on <i>asset</i> management.   ## Response Documents  <i>response document</i>s are electronic documents generated by an <i>agent</i> in response to a <i>request</i> for data.   The <i>response document</i>s defined in the MTConnect Standard are:  * <i>MTConnectDevices Response Document</i>: Describes the composition and configuration of the <i>Device</i> and the data that can be observed. See <see cref="MTConnectDevices Response Document">MTConnectDevices Response Document</see> and <see cref="Device Information Model">Device Information Model</see> for details on this information model.  * <i>MTConnectStreams Response Document</i>: <i>Observation</i>s made at a point in time about related <i>DataItem</i>s. See <see cref="MTConnectStreams Response Document">MTConnectStreams Response Document</see> and <see cref="Observation Information Model">Observation Information Model</see> for details on this information model.  * <i>MTConnectAssets Response Document</i>: <i>Asset</i>s  related to <i>Device</i>s. See <see cref="MTConnectAssets Response Document">MTConnectAssets Response Document</see> and <see cref="Asset Information Model">Asset Information Model</see> for details on this information model.  * <i>MTConnectErrors Response Document</i>: Information in response to a failed request. See <see cref="MTConnectErrors Response Document">MTConnectErrors Response Document</see> for details on this information model.  ## Request/Response Information Exchange  The transfer of information between an <i>agent</i> and a client software application is based on a <i>request and response</i> REST protocol. A client application requests specific information from an <i>agent</i> and an <i>agent</i> responds with a <i>response document</i>.  There are four types of <i>MTConnect Request</i>s. These <i>request</i>s are as follows:  * <i>probe request</i>: Requests information about one more more <i>Device</i>s as an <see cref="MTConnectDevices">MTConnectDevices</see> block.  * <i>current request</i>: Requests the most recent, or snapshot at a <i>sequence number</i>, <i>observation</i>s as an <see cref="MTConnectStreams">MTConnectStreams</see> block.  * <i>sample request</i>: Requests a series of <i>observation</i>s as an <see cref="MTConnectStreams">MTConnectStreams</see> block.  * <i>asset request</i>: Requests a set of <i>asset</i>s as an <see cref="MTConnectAssets">MTConnectAssets</see> block.  If an <i>agent</i> is unable to respond to the request for information or the request includes invalid information, the <i>agent</i> will publish an <i>MTConnectErrors Response Document</i>. See <see cref="MTConnectErrors">MTConnectErrors</see>.  See <see cref="REST Protocol">REST Protocol</see> for the details on the normative requirements of the agent./// Fundamentals Appendix
	/// <br/>Visit <seealso href="https://model.mtconnect.org/#Package__EAPK_496E1978_22AF_4543_A020_4616FFC25649">model.mtconnect.org</seealso> for more information.
	/// </summary>
	[GeneratedCode("MtconnectTranspiler.Sinks.CSharp", "2.3.0.0")]
	public class FundamentalsPackage : IPackage
	{
		/// <inheritdoc />
		public string ReferenceId => "EAPK_496E1978_22AF_4543_A020_4616FFC25649";
		
		/// <inheritdoc />
		public string Name => "Fundamentals";

		/// <inheritdoc />
		public string Summary => @"/// The MTConnect Standard defines the normative information model and protocol for retrieving information from manufacturing equipment. This document specifies the <i>agent</i> behavior and protocol.  ## Agent  The MTConnect Standard specifies the minimum functionality of the <i>agent</i>. The functionality is as follows:  * Provides store and forward messaging middleware service. * Provides key-value information storage and asset retrieval service. * Implements the REST API for the MTConnect Standard (See <see cref=""REST Protocol"">REST Protocol</see>).   * <i>Device</i> metadata.   * <i>observation</i>s collected by the agent.   * <i>asset</i>s collected by the agent.  There are three types of information stored by an <i>agent</i> that <b>MAY</b> be published in a <i>response document</i>. These are as follows:  * <i>equipment metadata</i> specified in <see cref=""Device Information Model"">Device Information Model</see>. * <i>streaming data</i> provides the <i>observation</i>s specified in <see cref=""Observation Information Model"">Observation Information Model</see>. * <i>Asset</i>s specified in <see cref=""Asset Information Model"">Asset Information Model</see>.  ### Agent Instance ID  The <i>agent</i> <b>MUST</b> set the <c>instanceId</c> to a unique value whenever the <i>sequence number</i> in the agent is initialized to <c>1</c>.  (see <see cref=""Sequence Numbers"">Sequence Numbers</see> and <see cref=""Persistence and Recovery"">Persistence and Recovery</see> below).   ### Storage of Equipment Metadata  An <i>agent</i> <b>MUST</b> be capable of publishing <i>equipment metadata</i> for the <i>agent</i> as specified in <see cref=""Device Information Model"">Device Information Model</see>.  ### Storage of Streaming Data  The <i>agent</i> <b>MAY</b> implement a <i>buffer</i> with a fixed number of <i>observation</i>s. If the <c>bufferSize</c> is fixed, the <i>agent</i> <b>MUST</b> store <i>observation</i>s using a first-in-first-out pattern. The <i>agent</i> will remove the oldest <i>observation</i> when the <i>buffer</i> is full and a new <i>observation</i> arrives.  ![Data Storage in Buffer](figures/data-storage-in-buffer.png ""data-storage-in-buffer""){: width=""0.8""}  In {{figure(first-in-first-out-buffer-management)}}, the maximum number of <i>observation</i>s that can be stored in the <i>buffer</i> of the <i>agent</i> is 8. The <c>bufferSize</c> in the header reports the maximum number of <i>observation</i>s. This example illustrates that when the <i>buffer</i> fills up, the oldest piece of data falls out the other end.  ![First In First Out Buffer Management](figures/first-in-first-out-buffer-management.png ""first-in-first-out-buffer-management""){: width=""0.8""}  > Note: As an implementation suggestion, the <i>buffer</i> should be sized large enough to provide a continuous stream of <i>observation</i>s. The implementer should also consider the impact of a temporary loss of communications when determining the size for the <i>buffer</i>. A larger <i>buffer</i> will allow more time to reconnect to an <i>agent</i> without losing data.  #### Sequence Numbers  In an <i>agent</i>, each occurrence of an <i>observation</i> in the <i>buffer</i> will be assigned a monotonically increasing unsigned 64-bit integer (<i>sequence number</i>) when it arrives. The first <i>sequence number</i> <b>MUST</b> be <c>1</c>.  The <i>sequence number</i> for each <i>observation</i> <b>MUST</b> be unique for an instance of an <i>agent</i> identified by an <c>instanceId</c>.  {{table(instanceid-and-sequence)}} illustrates the changing of the <c>instanceId</c> when an <i>agent</i> resets the <i>sequence number</i> to <c>1</c>.  | <c>instanceId</c> | <c>sequence</c> |  |-------------:|-----------:| |{{rowspan(5)}} 234556|234| ||235| ||236| ||237| ||238| |{{span(2)}} Agent Stops and Restarts| |{{rowspan(5)}} 234557|1| ||2| ||3| ||4| ||5| {: caption=""instanceId and sequence"" label=""instanceid-and-sequence"" }  {{figure(identifying-the-range-of-data-with-firstsequence-and-lastsequence)}} shows two additional pieces of information defined for an <i>agent</i>:  * <c>firstSequence</c> -- the oldest <i>observation</i> in the <i>buffer</i>. The <i>agent</i> removes this <i>observation</i> when it receives the next <i>observation</i>  * <c>lastSequence</c> -- the newest <i>observation</i> in the <i>buffer</i>  <c>firstSequence</c> and <c>lastSequence</c> provide the range of values for the REST API requests.  ![Indentifying the range of data with firstSequence and lastSequence](figures/identifying-the-range-of-data-with-firstsequence-and-lastsequence.png ""identifying-the-range-of-data-with-firstsequence-and-lastsequence""){: width=""0.75""}  The <i>agent</i> <b>MUST</b> begin evaluating <i>observation</i>s with <i>sample request</i>'s <c>from</c> parameter. Also, the <i>agent</i>  <b>MUST</b> include a maximum number of <i>observation</i>s given by the <c>count</c> parameter in the <i>response document</i>.  In {{figure(identifying-the-range-of-data-with-from-and-count)}}, the request specifies the <i>observation</i>s start at <i>sequence number</i> <c>15</c> (<c>from</c>) and includes a total of three items (<c>count</c>).  ![Identifying the range of data with from and count](figures/identifying-the-range-of-data-with-from-and-count.png ""identifying-the-range-of-data-with-from-and-count""){: width=""0.75""}  <c>nextSequence</c> header property has the <i>sequence number</i> of the next <i>observation</i> in the <i>buffer</i> for subsequent <i>sample request</i>s providing a contiguous set of <i>observation</i>s. In the example in {{figure(identifying-the-range-of-data-with-from-and-count)}}, the next <i>sequence number</i> (<c>nextSequence</c>) will be 18.  As shown in {{figure(identifying-the-range-of-data-with-nextsequence-and-lastsequence)}}, the combination of <c>from</c> and <c>count</c> defined by the <i>request</i> indicates a <i>sequence number</i> for data that is beyond that which is currently in the <i>buffer</i>. In this case, <c>nextSequence</c> is set to a value of <i> lastSequence + 1 </i>s.  ![Indentifying the range of data with nextSequence and lastSequence](figures/identifying-the-range-of-data-with-nextsequence-and-lastsequence.png ""identifying-the-range-of-data-with-nextsequence-and-lastsequence""){: width=""0.75""}  #### Observation Buffer  An <i>observation</i> has four pieces of information as follows:  1. <i>sequence number</i> associated with each <i>observation</i> - <c>sequence</c>. 2. The <c>timestamp</c> the <i>observation</i> was made. . 3. A reference to the <c>dataitemid</c> from the <see cref=""Device Information Model"">Device Information Model</see>. 4. The value of the <i>observation</i>.  {{table(data-storage-concept)}} is an example demonstrating the concept of how data may be stored in an <i>agent</i>:  | <c>sequence</c> | <c>timestamp</c> | <c>dataItemId</c> | <c>result</c> | |-----------:|------------:|-------------:|---------:| |<c>101</c>|<c>2016-12-13T09:44:00.2221Z</c>|<c>AVAIL-28277</c>|<c>UNAVAILABLE</c>| |<c>102</c>|<c>2016-12-13T09:54:00.3839Z</c>|<c>AVAIL-28277</c>|<c>AVAILABLE</c>| |<c>103</c>|<c>2016-12-13T10:00:00.0594Z</c>|<c>POS-Y-28277</c>|<c>25.348</c>| |<c>104</c>|<c>2016-12-13T10:00:00.0594Z</c>|<c>POS-Z-28277</c>|<c>13.23</c>| |<c>105</c>|<c>2016-12-13T10:00:03.2839Z</c>|<c>SS-28277</c>|<c>0</c>| |<c>106</c>|<c>2016-12-13T10:00:03.2839Z</c>|<c>POS-X-28277</c>|<c>11.195</c>| |<c>107</c>|<c>2016-12-13T10:00:03.2839Z</c>|<c>POS-Y-28277</c>|<c>24.938</c>| |<c>108</c>|<c>2016-12-13T10:01:37.8594Z</c>|<c>POS-Z-28277</c>|<c>1.143</c>| |<c>109</c>|<c>2016-12-13T10:02:03.2617Z</c>|<c>SS-28277</c>|<c>1002</c>| {: caption=""Data Storage Concept"" label=""data-storage-concept"" }  #### Timestamp  <i>observation</i>s <b>MUST</b> have a <c>timestamp</c> giving the most accurate time that the <i>observation</i> occurred.  The timezone of the <c>timestamp</c> <b>MUST</b> be UTC (Coordinated Universal Time)  and represented using ISO 8601 format: e.g., ""2010-04-01T21:22:43Z"".  Applications <b>SHOULD</b> use the <i>observation</i>'s <c>timestamp</c> for ordering as opposed to <i>sequence number</i>.  All <i>observation</i>s occurring at the same time <b>MUST</b> have the same <c>timestamp</c>.   #### Recording Occurrences of Streaming Data  The <i>agent</i> <b>MUST</b> only place <i>observation</i>s in the <i>buffer</i> if the data has changed from the previous <i>observation</i> for the same <see cref=""DataItem"">DataItem</see>.   The <i>agent</i> <b>MUST</b> place every <i>observation</i> in the <i>buffer</i>, without checking for changes, in the following cases:  * The <see cref=""DataItem::discrete"" /> is <c>true</c>.  * The <see cref=""DataItem::representation"" /> is <c>DISCRETE</c>. * The <see cref=""DataItem::representation"" /> is <c>TIME_SERIES</c>.  #### Maintaining Last Value for Data Entities  An <i>agent</i> <b>MUST</b> retain the most recent <i>observation</i> associated with each <see cref=""DataItem"">DataItem</see>, even if the <i>observation</i> is no longer in the <i>buffer</i>. This function supports the <i>current request</i> functionality.  #### Unavailability of Data  An <i>observation</i> with the value of <c>UNAVAILABLE</c> indicates the value is indeterminate.  The <i>agent</i> <b>MUST</b> initialize every <see cref=""DataItem"">DataItem</see>, unless it has a constant value (see below), with an <i>observation</i> with the value of <c>UNAVAILABLE</c>. Aditionally, whenever the data source is unreachable, every <see cref=""DataItem"">DataItem</see> associated with the data source must have an <i>observation</i> with the value of <c>UNAVAILABLE</c> and <c>timestamp</c> when the connection was lost.   An <see cref=""DataItem"">DataItem</see> that is constrained to a constant value, as defined in <see cref=""Device Information Model"">Device Information Model</see>, <b>MUST</b> only have an <i>observation</i> with the constant value and <b>MUST NOT</b> be set to <c>UNAVAILABLE</c>.  #### Persistence and Recovery  The <i>agent</i> <b>MAY</b> have a fixed size <i>buffer</i> and the <i>buffer</i> <b>MAY</b> be ephemeral.  If the <i>buffer</i> is recoverable, the <i>agent</i> <b>MUST NOT</b> change the <c>instanceId</c> and <b>MUST NOT</b> set the <i>sequence number</i> to <c>1</c>. The <i>sequence number</i> <b>MUST</b> be one greater than the maximum value of the recovered <i>observation</i>s. <i> max(sequence) + 1 </i>s  ### Storage of MTConnect Assets  An <i>agent</i> <b>MAY</b> only retain a limited number of <see cref=""Asset"">Asset</see>s in the <i>asset buffer</i>. The <see cref=""Asset"">Asset</see>s are stored in first-in-first-out method where the oldest <see cref=""Asset"">Asset</see> is removed when the <i>asset buffer</i> is full and a new <see cref=""Asset"">Asset</see> arrives.  {{figure(first-in-first-out-asset-buffer-management)}} illustrates the oldest <see cref=""Asset"">Asset</see> being removed from the <i>asset buffer</i> when a new <see cref=""Asset"">Asset</see> is added and the <i>asset buffer</i> is full:  ![First In First Out Asset Buffer Management](figures/first-in-first-out-asset-buffer-management.png ""first-in-first-out-asset-buffer-management""){: width=""0.6""}  <see cref=""Asset"">Asset</see>s are indexed by <see cref=""Asset::assetId"" />. In the case of <see cref=""Asset"">Asset</see>s, {{figure(relationship-between-assetid-and-stored-asset-documents)}} demonstrates the relationship between the key (<see cref=""Asset::assetId"" />) and the stored <see cref=""Asset"">Asset</see>:  ![Relationship between assetId and stored Asset documents](figures/relationship-between-assetid-and-stored-asset-documents.png ""relationship-between-assetid-and-stored-asset-documents""){: width=""0.25""}  > Note: The key (<see cref=""Asset::assetId"" />) is independent of the order of the <see cref=""Asset"">Asset</see> stored in the <i>asset buffer</i>.  When the <i>agent</i> receives a new <see cref=""Asset"">Asset</see>, one of the following rules <b>MUST</b> apply:  * If the <see cref=""Asset"">Asset</see> is not in the <i>asset buffer</i>, the <i>agent</i> <b>MUST</b> add the new <see cref=""Asset"">Asset</see> to the front of the <i>asset buffer</i>. If the <i>asset buffer</i> is full, the oldest <see cref=""Asset"">Asset</see> will be removed from the <i>asset buffer</i>.  * If the <see cref=""Asset"">Asset</see> is already in the <i>asset buffer</i>, the <i>agent</i> <b>MUST</b> replace the existing <see cref=""Asset"">Asset</see> and move the <see cref=""Asset"">Asset</see> to the front of the <i>asset buffer</i>.   The number of <see cref=""Asset"">Asset</see> that may be stored in an <i>agent</i> is defined by the value for <see cref=""Header::assetBufferSize"" />. An <see cref=""Header::assetBufferSize"" /> of 4,294,967,296 or <i> 2^{32 } </i>s <b>MUST</b> indicate unlimited storage.  The <i>asset buffer</i> <b>MAY</b> be ephemeral and the <see cref=""Asset"">Asset</see> entities will be lost if the <i>agent</i> clears the <i>asset buffer</i>. They must be recovered from the data source.  <see cref=""Asset Information Model"">Asset Information Model</see> provides additional information on <i>asset</i> management.   ## Response Documents  <i>response document</i>s are electronic documents generated by an <i>agent</i> in response to a <i>request</i> for data.   The <i>response document</i>s defined in the MTConnect Standard are:  * <i>MTConnectDevices Response Document</i>: Describes the composition and configuration of the <i>Device</i> and the data that can be observed. See <see cref=""MTConnectDevices Response Document"">MTConnectDevices Response Document</see> and <see cref=""Device Information Model"">Device Information Model</see> for details on this information model.  * <i>MTConnectStreams Response Document</i>: <i>Observation</i>s made at a point in time about related <i>DataItem</i>s. See <see cref=""MTConnectStreams Response Document"">MTConnectStreams Response Document</see> and <see cref=""Observation Information Model"">Observation Information Model</see> for details on this information model.  * <i>MTConnectAssets Response Document</i>: <i>Asset</i>s  related to <i>Device</i>s. See <see cref=""MTConnectAssets Response Document"">MTConnectAssets Response Document</see> and <see cref=""Asset Information Model"">Asset Information Model</see> for details on this information model.  * <i>MTConnectErrors Response Document</i>: Information in response to a failed request. See <see cref=""MTConnectErrors Response Document"">MTConnectErrors Response Document</see> for details on this information model.  ## Request/Response Information Exchange  The transfer of information between an <i>agent</i> and a client software application is based on a <i>request and response</i> REST protocol. A client application requests specific information from an <i>agent</i> and an <i>agent</i> responds with a <i>response document</i>.  There are four types of <i>MTConnect Request</i>s. These <i>request</i>s are as follows:  * <i>probe request</i>: Requests information about one more more <i>Device</i>s as an <see cref=""MTConnectDevices"">MTConnectDevices</see> block.  * <i>current request</i>: Requests the most recent, or snapshot at a <i>sequence number</i>, <i>observation</i>s as an <see cref=""MTConnectStreams"">MTConnectStreams</see> block.  * <i>sample request</i>: Requests a series of <i>observation</i>s as an <see cref=""MTConnectStreams"">MTConnectStreams</see> block.  * <i>asset request</i>: Requests a set of <i>asset</i>s as an <see cref=""MTConnectAssets"">MTConnectAssets</see> block.  If an <i>agent</i> is unable to respond to the request for information or the request includes invalid information, the <i>agent</i> will publish an <i>MTConnectErrors Response Document</i>. See <see cref=""MTConnectErrors"">MTConnectErrors</see>.  See <see cref=""REST Protocol"">REST Protocol</see> for the details on the normative requirements of the agent./// Fundamentals Appendix";

		/// <inheritdoc />
		public IPackage[] Packages => new IPackage[] {
			MTConnectProtocolPackage,
		};
		
		/// <inheritdoc />
		public IClass[] Classes => new IClass[] {
		};
		#region Packages
	private Package.MTConnectProtocolPackage _MTConnectProtocolPackage;
	/// <summary>
	/// <inheritdoc cref="Package.MTConnectProtocolPackage" path="/summary" />
	/// </summary>
	public Package.MTConnectProtocolPackage MTConnectProtocolPackage => _MTConnectProtocolPackage ?? (_MTConnectProtocolPackage = new Package.MTConnectProtocolPackage());

	#endregion

	#region Classes
	#endregion
	}
}